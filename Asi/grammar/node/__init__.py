# This file was generated by SableCC (http://www.sablecc.org/).

from types import ListType
from Asi.grammar.utils import StringBuffer,  abstract


class Node(object):
    def __init__(self):
        if self.__class__ is Node:
            raise TypeError("Node class can not be instantiated.")
        self.parent = None

    def clone(self):
        abstract()

    def getparent(self):
        return self.parent

    def setparent(self,  parent):
        self.parent = parent

    def removeChild(self,  child):
        abstract()

    def replaceChild(self,  oldChild,  newChild):
        abstract()

    def replaceBy(self,  node):
        if self.parent is not None:
            self.parent.replaceChild(self,  node)

    def toString(self,  other):
        if isinstance(other,  ListType):
            sb = StringBuffer()

            for node in other:
                sb.append(node)

            return str(sb)

        if other is not None:
            return str(other)

        return ''

    def cloneNode(self,  node):
        if node is not None:
            return node.clone()

        return None

    def cloneList(self,  lst):
        clone = list()

        for node in lst:
            clone.append(node.clone())

        return clone

    def apply(self,  analysis):
        abstract()


class Token(Node):
    def __init__(self):
        super(Token,  self).__init__()
        self.text = None
        self.line = 0
        self.pos = 0

    def getText(self):
        return self.text

    def setText(self,  text):
        self.text = text

    def getLine(self):
        return self.line

    def setLine(self,  line):
        self.line = line

    def getPos(self):
        return self.pos

    def setPos(self,  pos):
        self.pos = pos

    def __str__(self):
        return self.text + " "

    def removeChild(self,  child):
        pass

    def replaceChild(self,  oldChild,   newChild):
        pass


class TMin(Token):
    TokenIndex = 0

    def __init__(self,  line=0,  pos=0):
        super(TMin,  self).__init__()
        super(TMin,  self).setText("-")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TMin(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTMin(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TMin text.")


class TAnd(Token):
    TokenIndex = 1

    def __init__(self,  line=0,  pos=0):
        super(TAnd,  self).__init__()
        super(TAnd,  self).setText("AND")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TAnd(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTAnd(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TAnd text.")


class TOr(Token):
    TokenIndex = 2

    def __init__(self,  line=0,  pos=0):
        super(TOr,  self).__init__()
        super(TOr,  self).setText("OR")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TOr(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTOr(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TOr text.")


class TNot(Token):
    TokenIndex = 3

    def __init__(self,  line=0,  pos=0):
        super(TNot,  self).__init__()
        super(TNot,  self).setText("NOT")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TNot(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTNot(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TNot text.")


class TExclude(Token):
    TokenIndex = 4

    def __init__(self,  line=0,  pos=0):
        super(TExclude,  self).__init__()
        super(TExclude,  self).setText("EXCLUDE")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TExclude(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTExclude(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TExclude text.")


class TSelect(Token):
    TokenIndex = 5

    def __init__(self,  line=0,  pos=0):
        super(TSelect,  self).__init__()
        super(TSelect,  self).setText("SELECT")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TSelect(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTSelect(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TSelect text.")


class TFrom(Token):
    TokenIndex = 6

    def __init__(self,  line=0,  pos=0):
        super(TFrom,  self).__init__()
        super(TFrom,  self).setText("FROM")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TFrom(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTFrom(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TFrom text.")


class TAtleast(Token):
    TokenIndex = 7

    def __init__(self,  line=0,  pos=0):
        super(TAtleast,  self).__init__()
        super(TAtleast,  self).setText("ATLEAST")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TAtleast(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTAtleast(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TAtleast text.")


class TExactly(Token):
    TokenIndex = 8

    def __init__(self,  line=0,  pos=0):
        super(TExactly,  self).__init__()
        super(TExactly,  self).setText("EXACTLY")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TExactly(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTExactly(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TExactly text.")


class TNotmorethan(Token):
    TokenIndex = 9

    def __init__(self,  line=0,  pos=0):
        super(TNotmorethan,  self).__init__()
        super(TNotmorethan,  self).setText("NOTMORETHAN")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TNotmorethan(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTNotmorethan(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TNotmorethan text.")


class TScore(Token):
    TokenIndex = 10

    def __init__(self,  line=0,  pos=0):
        super(TScore,  self).__init__()
        super(TScore,  self).setText("SCORE")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TScore(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTScore(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TScore text.")


class TMax(Token):
    TokenIndex = 11

    def __init__(self,  line=0,  pos=0):
        super(TMax,  self).__init__()
        super(TMax,  self).setText("MAX")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TMax(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTMax(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TMax text.")


class TLPar(Token):
    TokenIndex = 12

    def __init__(self,  line=0,  pos=0):
        super(TLPar,  self).__init__()
        super(TLPar,  self).setText("(")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TLPar(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTLPar(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TLPar text.")


class TRPar(Token):
    TokenIndex = 13

    def __init__(self,  line=0,  pos=0):
        super(TRPar,  self).__init__()
        super(TRPar,  self).setText(")")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TRPar(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTRPar(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TRPar text.")


class TMapper(Token):
    TokenIndex = 14

    def __init__(self,  line=0,  pos=0):
        super(TMapper,  self).__init__()
        super(TMapper,  self).setText("=>")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TMapper(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTMapper(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TMapper text.")


class TComma(Token):
    TokenIndex = 15

    def __init__(self,  line=0,  pos=0):
        super(TComma,  self).__init__()
        super(TComma,  self).setText(", ")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TComma(self.getLine(),  self.getPos())

    def __copy__(self):
        return self.clone()

    def apply(self,  analysis):
        analysis.caseTComma(self)

    def setText(self,  text):
        raise RuntimeError("Cannot change TComma text.")


class TBlank(Token):
    TokenIndex = -1

    def __init__(self,  text,  line=0,  pos=0):
        super(TBlank,  self).__init__()
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TBlank(self.getText(),  self.getLine(),  self.getPos())

    def apply(self,  analysis):
        analysis.caseTBlank(self)


class TInteger(Token):
    TokenIndex = 16

    def __init__(self,  text,  line=0,  pos=0):
        super(TInteger,  self).__init__()
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TInteger(self.getText(),  self.getLine(),  self.getPos())

    def apply(self,  analysis):
        analysis.caseTInteger(self)


class TFloat(Token):
    TokenIndex = 17

    def __init__(self,  text,  line=0,  pos=0):
        super(TFloat,  self).__init__()
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TFloat(self.getText(),  self.getLine(),  self.getPos())

    def apply(self,  analysis):
        analysis.caseTFloat(self)


class TAminoAcid(Token):
    TokenIndex = 18

    def __init__(self,  text,  line=0,  pos=0):
        super(TAminoAcid,  self).__init__()
        self.setText(text)
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return TAminoAcid(self.getText(),  self.getLine(),  self.getPos())

    def apply(self,  analysis):
        analysis.caseTAminoAcid(self)


class EOF(Token):
    TokenIndex = 19

    def __init__(self,  line=0,  pos=0):
        super(EOF,  self).__init__()
        self.setText("")
        self.setLine(line)
        self.setPos(pos)

    def clone(self):
        return EOF(self.getLine(),  self.getPos())

    def apply(self,  analysis):
        analysis.caseEOF(self)


class ALogicstatementStatement(Node):
    def __init__(self,  _booleancondition_=None):
        super(ALogicstatementStatement,  self).__init__()
        self._booleancondition_ = None
        if _booleancondition_ is not None:
            self.setBooleancondition(_booleancondition_)

    def clone(self):
        return ALogicstatementStatement(self.cloneNode(self._booleancondition_))

    def apply(self,  analysis):
        analysis.caseALogicstatementStatement(self)

    def getBooleancondition(self):
        return self._booleancondition_

    def setBooleancondition(self,  node):
        if self._booleancondition_ is not None:
            self._booleancondition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._booleancondition_ = node

    def __str__(self):
        return '' + self.toString(self._booleancondition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._booleancondition_ == child:
            self._booleancondition_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._booleancondition_ == oldChild:
            self.setBooleancondition(newChild)
            return


class AScoreStatement(Node):
    def __init__(self,  _scorecondition_=None):
        super(AScoreStatement,  self).__init__()
        self._scorecondition_ = None
        if _scorecondition_ is not None:
            self.setScorecondition(_scorecondition_)

    def clone(self):
        return AScoreStatement(self.cloneNode(self._scorecondition_))

    def apply(self,  analysis):
        analysis.caseAScoreStatement(self)

    def getScorecondition(self):
        return self._scorecondition_

    def setScorecondition(self,  node):
        if self._scorecondition_ is not None:
            self._scorecondition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._scorecondition_ = node

    def __str__(self):
        return '' + self.toString(self._scorecondition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._scorecondition_ == child:
            self._scorecondition_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._scorecondition_ == oldChild:
            self.setScorecondition(newChild)
            return


class ABooleancondition(Node):
    def __init__(self,  _condition_=None, _condition2_=None):
        super(ABooleancondition,  self).__init__()
        self._condition_ = None
        self._condition2_ = list()
        if _condition_ is not None:
            self.setCondition(_condition_)
        if _condition2_ is not None:
            self._condition2_.extend(_condition2_)

    def clone(self):
        return ABooleancondition(self.cloneNode(self._condition_),
                                 self.cloneList(self._condition2_))

    def apply(self,  analysis):
        analysis.caseABooleancondition(self)

    def getCondition(self):
        return self._condition_

    def setCondition(self,  node):
        if self._condition_ is not None:
            self._condition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._condition_ = node

    def getCondition2(self):
        return self._condition2_

    def setCondition2(self,  lst):
        del self._condition2_[0:len(self._condition2_)]
        self._condition2_.extend(lst)

    def __str__(self):
        return '' + self.toString(self._condition_) + self.toString(self._condition2_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._condition_ == child:
            self._condition_ = None
            return
        if child in self._condition2_:
            self._condition2_.remove(child)
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._condition_ == oldChild:
            self.setCondition(newChild)
            return
        for i in range(self._condition2_):
            if self._condition2_[i] == oldChild:
                if newChild is not None:
                    self._condition2_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._condition2_[i]
                oldChild.setparent(None)
                return


class AStatementCondition(Node):
    def __init__(self,  _l_par_=None, _booleancondition_=None, _r_par_=None):
        super(AStatementCondition,  self).__init__()
        self._l_par_ = None
        self._booleancondition_ = None
        self._r_par_ = None
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _booleancondition_ is not None:
            self.setBooleancondition(_booleancondition_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AStatementCondition(self.cloneNode(self._l_par_),
                                   self.cloneNode(self._booleancondition_),
                                   self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAStatementCondition(self)

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getBooleancondition(self):
        return self._booleancondition_

    def setBooleancondition(self,  node):
        if self._booleancondition_ is not None:
            self._booleancondition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._booleancondition_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._l_par_) + self.toString(self._booleancondition_) \
               + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._booleancondition_ == child:
            self._booleancondition_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._booleancondition_ == oldChild:
            self.setBooleancondition(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AResidueCondition(Node):
    def __init__(self,  _residue_=None):
        super(AResidueCondition,  self).__init__()
        self._residue_ = None
        if _residue_ is not None:
            self.setResidue(_residue_)

    def clone(self):
        return AResidueCondition(self.cloneNode(self._residue_))

    def apply(self,  analysis):
        analysis.caseAResidueCondition(self)

    def getResidue(self):
        return self._residue_

    def setResidue(self,  node):
        if self._residue_ is not None:
            self._residue_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.toString(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._residue_ == child:
            self._residue_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._residue_ == oldChild:
            self.setResidue(newChild)
            return


class AExcludeCondition(Node):
    def __init__(self,  _excludestatement_=None):
        super(AExcludeCondition,  self).__init__()
        self._excludestatement_ = None
        if _excludestatement_ is not None:
            self.setExcludestatement(_excludestatement_)

    def clone(self):
        return AExcludeCondition(self.cloneNode(self._excludestatement_))

    def apply(self,  analysis):
        analysis.caseAExcludeCondition(self)

    def getExcludestatement(self):
        return self._excludestatement_

    def setExcludestatement(self,  node):
        if self._excludestatement_ is not None:
            self._excludestatement_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._excludestatement_ = node

    def __str__(self):
        return '' + self.toString(self._excludestatement_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._excludestatement_ == child:
            self._excludestatement_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._excludestatement_ == oldChild:
            self.setExcludestatement(newChild)
            return


class ASelectCondition(Node):
    def __init__(self,  _selectstatement_=None):
        super(ASelectCondition,  self).__init__()
        self._selectstatement_ = None
        if _selectstatement_ is not None:
            self.setSelectstatement(_selectstatement_)

    def clone(self):
        return ASelectCondition(self.cloneNode(self._selectstatement_))

    def apply(self,  analysis):
        analysis.caseASelectCondition(self)

    def getSelectstatement(self):
        return self._selectstatement_

    def setSelectstatement(self,  node):
        if self._selectstatement_ is not None:
            self._selectstatement_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectstatement_ = node

    def __str__(self):
        return '' + self.toString(self._selectstatement_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._selectstatement_ == child:
            self._selectstatement_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._selectstatement_ == oldChild:
            self.setSelectstatement(newChild)
            return


class ACondition2(Node):
    def __init__(self,  _logicsymbol_=None, _condition_=None):
        super(ACondition2,  self).__init__()
        self._logicsymbol_ = None
        self._condition_ = None
        if _logicsymbol_ is not None:
            self.setLogicsymbol(_logicsymbol_)
        if _condition_ is not None:
            self.setCondition(_condition_)

    def clone(self):
        return ACondition2(self.cloneNode(self._logicsymbol_), self.cloneNode(self._condition_))

    def apply(self,  analysis):
        analysis.caseACondition2(self)

    def getLogicsymbol(self):
        return self._logicsymbol_

    def setLogicsymbol(self,  node):
        if self._logicsymbol_ is not None:
            self._logicsymbol_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._logicsymbol_ = node

    def getCondition(self):
        return self._condition_

    def setCondition(self,  node):
        if self._condition_ is not None:
            self._condition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._condition_ = node

    def __str__(self):
        return '' + self.toString(self._logicsymbol_) + self.toString(self._condition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._logicsymbol_ == child:
            self._logicsymbol_ = None
            return
        if self._condition_ == child:
            self._condition_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._logicsymbol_ == oldChild:
            self.setLogicsymbol(newChild)
            return
        if self._condition_ == oldChild:
            self.setCondition(newChild)
            return


class AAndLogicsymbol(Node):
    def __init__(self,  _and_=None):
        super(AAndLogicsymbol,  self).__init__()
        self._and_ = None
        if _and_ is not None:
            self.setAnd(_and_)

    def clone(self):
        return AAndLogicsymbol(self.cloneNode(self._and_))

    def apply(self,  analysis):
        analysis.caseAAndLogicsymbol(self)

    def getAnd(self):
        return self._and_

    def setAnd(self,  node):
        if self._and_ is not None:
            self._and_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._and_ = node

    def __str__(self):
        return '' + self.toString(self._and_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._and_ == child:
            self._and_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._and_ == oldChild:
            self.setAnd(newChild)
            return


class AOrLogicsymbol(Node):
    def __init__(self,  _or_=None):
        super(AOrLogicsymbol,  self).__init__()
        self._or_ = None
        if _or_ is not None:
            self.setOr(_or_)

    def clone(self):
        return AOrLogicsymbol(self.cloneNode(self._or_))

    def apply(self,  analysis):
        analysis.caseAOrLogicsymbol(self)

    def getOr(self):
        return self._or_

    def setOr(self,  node):
        if self._or_ is not None:
            self._or_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._or_ = node

    def __str__(self):
        return '' + self.toString(self._or_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._or_ == child:
            self._or_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._or_ == oldChild:
            self.setOr(newChild)
            return


class AResidueResidue(Node):
    def __init__(self,  _originalaminoacid_=None, _integer_=None, _mutatedaminoacid_=None):
        super(AResidueResidue,  self).__init__()
        self._originalaminoacid_ = None
        self._integer_ = None
        self._mutatedaminoacid_ = list()
        if _originalaminoacid_ is not None:
            self.setOriginalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)

    def clone(self):
        return AResidueResidue(self.cloneNode(self._originalaminoacid_),
                               self.cloneNode(self._integer_),
                               self.cloneList(self._mutatedaminoacid_))

    def apply(self,  analysis):
        analysis.caseAResidueResidue(self)

    def getOriginalaminoacid(self):
        return self._originalaminoacid_

    def setOriginalaminoacid(self,  node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._originalaminoacid_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getMutatedaminoacid(self):
        return self._mutatedaminoacid_

    def setMutatedaminoacid(self,  lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def __str__(self):
        return '' + self.toString(self._originalaminoacid_) + self.toString(self._integer_) \
               + self.toString(self._mutatedaminoacid_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._originalaminoacid_ == oldChild:
            self.setOriginalaminoacid(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        for i in range(self._mutatedaminoacid_):
            if self._mutatedaminoacid_[i] == oldChild:
                if newChild is not None:
                    self._mutatedaminoacid_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._mutatedaminoacid_[i]
                oldChild.setparent(None)
                return


class AResiduenotResidue(Node):
    def __init__(self,  _not_=None, _originalaminoacid_=None, _integer_=None,
                 _mutatedaminoacid_=None):
        super(AResiduenotResidue,  self).__init__()
        self._not_ = None
        self._originalaminoacid_ = None
        self._integer_ = None
        self._mutatedaminoacid_ = list()
        if _not_ is not None:
            self.setNot(_not_)
        if _originalaminoacid_ is not None:
            self.setOriginalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)

    def clone(self):
        return AResiduenotResidue(self.cloneNode(self._not_),
                                  self.cloneNode(self._originalaminoacid_),
                                  self.cloneNode(self._integer_),
                                  self.cloneList(self._mutatedaminoacid_))

    def apply(self,  analysis):
        analysis.caseAResiduenotResidue(self)

    def getNot(self):
        return self._not_

    def setNot(self,  node):
        if self._not_ is not None:
            self._not_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._not_ = node

    def getOriginalaminoacid(self):
        return self._originalaminoacid_

    def setOriginalaminoacid(self,  node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._originalaminoacid_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getMutatedaminoacid(self):
        return self._mutatedaminoacid_

    def setMutatedaminoacid(self,  lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def __str__(self):
        return '' + self.toString(self._not_) + self.toString(self._originalaminoacid_) \
               + self.toString(self._integer_) + self.toString(self._mutatedaminoacid_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._not_ == child:
            self._not_ = None
            return
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._not_ == oldChild:
            self.setNot(newChild)
            return
        if self._originalaminoacid_ == oldChild:
            self.setOriginalaminoacid(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        for i in range(self._mutatedaminoacid_):
            if self._mutatedaminoacid_[i] == oldChild:
                if newChild is not None:
                    self._mutatedaminoacid_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._mutatedaminoacid_[i]
                oldChild.setparent(None)
                return


class AResidueinvertResidue(Node):
    def __init__(self,  _originalaminoacid_=None, _integer_=None, _l_par_=None, _not_=None,
                 _mutatedaminoacid_=None, _r_par_=None):
        super(AResidueinvertResidue,  self).__init__()
        self._originalaminoacid_ = None
        self._integer_ = None
        self._l_par_ = None
        self._not_ = None
        self._mutatedaminoacid_ = list()
        self._r_par_ = None
        if _originalaminoacid_ is not None:
            self.setOriginalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _not_ is not None:
            self.setNot(_not_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AResidueinvertResidue(self.cloneNode(self._originalaminoacid_),
                                     self.cloneNode(self._integer_),
                                     self.cloneNode(self._l_par_),
                                     self.cloneNode(self._not_),
                                     self.cloneList(self._mutatedaminoacid_),
                                     self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAResidueinvertResidue(self)

    def getOriginalaminoacid(self):
        return self._originalaminoacid_

    def setOriginalaminoacid(self,  node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._originalaminoacid_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getNot(self):
        return self._not_

    def setNot(self,  node):
        if self._not_ is not None:
            self._not_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._not_ = node

    def getMutatedaminoacid(self):
        return self._mutatedaminoacid_

    def setMutatedaminoacid(self,  lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._originalaminoacid_) + self.toString(self._integer_) \
               + self.toString(self._l_par_) + self.toString(self._not_) \
               + self.toString(self._mutatedaminoacid_) + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._not_ == child:
            self._not_ = None
            return
        if child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._originalaminoacid_ == oldChild:
            self.setOriginalaminoacid(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._not_ == oldChild:
            self.setNot(newChild)
            return
        for i in range(self._mutatedaminoacid_):
            if self._mutatedaminoacid_[i] == oldChild:
                if newChild is not None:
                    self._mutatedaminoacid_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._mutatedaminoacid_[i]
                oldChild.setparent(None)
                return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AExcludestatement(Node):
    def __init__(self,  _exclude_=None, _residue_=None):
        super(AExcludestatement,  self).__init__()
        self._exclude_ = None
        self._residue_ = None
        if _exclude_ is not None:
            self.setExclude(_exclude_)
        if _residue_ is not None:
            self.setResidue(_residue_)

    def clone(self):
        return AExcludestatement(self.cloneNode(self._exclude_), self.cloneNode(self._residue_))

    def apply(self,  analysis):
        analysis.caseAExcludestatement(self)

    def getExclude(self):
        return self._exclude_

    def setExclude(self,  node):
        if self._exclude_ is not None:
            self._exclude_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._exclude_ = node

    def getResidue(self):
        return self._residue_

    def setResidue(self,  node):
        if self._residue_ is not None:
            self._residue_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.toString(self._exclude_) + self.toString(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._exclude_ == child:
            self._exclude_ = None
            return
        if self._residue_ == child:
            self._residue_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._exclude_ == oldChild:
            self.setExclude(newChild)
            return
        if self._residue_ == oldChild:
            self.setResidue(newChild)
            return


class ASelectstatement(Node):
    def __init__(self,  _select_=None, _selectstatement2_=None):
        super(ASelectstatement,  self).__init__()
        self._select_ = None
        self._selectstatement2_ = None
        if _select_ is not None:
            self.setSelect(_select_)
        if _selectstatement2_ is not None:
            self.setSelectstatement2(_selectstatement2_)

    def clone(self):
        return ASelectstatement(self.cloneNode(self._select_),
                                self.cloneNode(self._selectstatement2_))

    def apply(self,  analysis):
        analysis.caseASelectstatement(self)

    def getSelect(self):
        return self._select_

    def setSelect(self,  node):
        if self._select_ is not None:
            self._select_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._select_ = node

    def getSelectstatement2(self):
        return self._selectstatement2_

    def setSelectstatement2(self,  node):
        if self._selectstatement2_ is not None:
            self._selectstatement2_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectstatement2_ = node

    def __str__(self):
        return '' + self.toString(self._select_) + self.toString(self._selectstatement2_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._select_ == child:
            self._select_ = None
            return
        if self._selectstatement2_ == child:
            self._selectstatement2_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._select_ == oldChild:
            self.setSelect(newChild)
            return
        if self._selectstatement2_ == oldChild:
            self.setSelectstatement2(newChild)
            return


class AExactlySelectstatement2(Node):
    def __init__(self,  _exactly_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AExactlySelectstatement2,  self).__init__()
        self._exactly_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _exactly_ is not None:
            self.setExactly(_exactly_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _from_ is not None:
            self.setFrom(_from_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _selectlist_ is not None:
            self.setSelectlist(_selectlist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AExactlySelectstatement2(self.cloneNode(self._exactly_),
                                        self.cloneNode(self._integer_),
                                        self.cloneNode(self._from_),
                                        self.cloneNode(self._l_par_),
                                        self.cloneNode(self._selectlist_),
                                        self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAExactlySelectstatement2(self)

    def getExactly(self):
        return self._exactly_

    def setExactly(self,  node):
        if self._exactly_ is not None:
            self._exactly_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._exactly_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getFrom(self):
        return self._from_

    def setFrom(self,  node):
        if self._from_ is not None:
            self._from_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._from_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getSelectlist(self):
        return self._selectlist_

    def setSelectlist(self,  node):
        if self._selectlist_ is not None:
            self._selectlist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectlist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._exactly_) + self.toString(self._integer_) \
               + self.toString(self._from_) + self.toString(self._l_par_) \
               + self.toString(self._selectlist_) + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._exactly_ == child:
            self._exactly_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if self._from_ == child:
            self._from_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._selectlist_ == child:
            self._selectlist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._exactly_ == oldChild:
            self.setExactly(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        if self._from_ == oldChild:
            self.setFrom(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._selectlist_ == oldChild:
            self.setSelectlist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AAtleastSelectstatement2(Node):
    def __init__(self,  _atleast_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AAtleastSelectstatement2,  self).__init__()
        self._atleast_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _atleast_ is not None:
            self.setAtleast(_atleast_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _from_ is not None:
            self.setFrom(_from_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _selectlist_ is not None:
            self.setSelectlist(_selectlist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AAtleastSelectstatement2(self.cloneNode(self._atleast_),
                                        self.cloneNode(self._integer_),
                                        self.cloneNode(self._from_),
                                        self.cloneNode(self._l_par_),
                                        self.cloneNode(self._selectlist_),
                                        self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAAtleastSelectstatement2(self)

    def getAtleast(self):
        return self._atleast_

    def setAtleast(self,  node):
        if self._atleast_ is not None:
            self._atleast_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._atleast_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getFrom(self):
        return self._from_

    def setFrom(self,  node):
        if self._from_ is not None:
            self._from_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._from_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getSelectlist(self):
        return self._selectlist_

    def setSelectlist(self,  node):
        if self._selectlist_ is not None:
            self._selectlist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectlist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._atleast_) + self.toString(self._integer_) \
               + self.toString(self._from_) + self.toString(self._l_par_) \
               + self.toString(self._selectlist_) + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._atleast_ == child:
            self._atleast_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if self._from_ == child:
            self._from_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._selectlist_ == child:
            self._selectlist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._atleast_ == oldChild:
            self.setAtleast(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        if self._from_ == oldChild:
            self.setFrom(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._selectlist_ == oldChild:
            self.setSelectlist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class ANotmorethanSelectstatement2(Node):
    def __init__(self,  _notmorethan_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(ANotmorethanSelectstatement2,  self).__init__()
        self._notmorethan_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _notmorethan_ is not None:
            self.setNotmorethan(_notmorethan_)
        if _integer_ is not None:
            self.setInteger(_integer_)
        if _from_ is not None:
            self.setFrom(_from_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _selectlist_ is not None:
            self.setSelectlist(_selectlist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return ANotmorethanSelectstatement2(self.cloneNode(self._notmorethan_),
                                            self.cloneNode(self._integer_),
                                            self.cloneNode(self._from_),
                                            self.cloneNode(self._l_par_),
                                            self.cloneNode(self._selectlist_),
                                            self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseANotmorethanSelectstatement2(self)

    def getNotmorethan(self):
        return self._notmorethan_

    def setNotmorethan(self,  node):
        if self._notmorethan_ is not None:
            self._notmorethan_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._notmorethan_ = node

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def getFrom(self):
        return self._from_

    def setFrom(self,  node):
        if self._from_ is not None:
            self._from_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._from_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getSelectlist(self):
        return self._selectlist_

    def setSelectlist(self,  node):
        if self._selectlist_ is not None:
            self._selectlist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectlist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._notmorethan_) + self.toString(self._integer_) \
               + self.toString(self._from_) + self.toString(self._l_par_) \
               + self.toString(self._selectlist_) + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._notmorethan_ == child:
            self._notmorethan_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if self._from_ == child:
            self._from_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._selectlist_ == child:
            self._selectlist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._notmorethan_ == oldChild:
            self.setNotmorethan(newChild)
            return
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return
        if self._from_ == oldChild:
            self.setFrom(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._selectlist_ == oldChild:
            self.setSelectlist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AAtleastnotmorethanSelectstatement2(Node):
    def __init__(self,  _atleast_=None, _atleastnumber_=None, _logicsymbol_=None,
                 _notmorethan_=None, _notmorethannumber_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AAtleastnotmorethanSelectstatement2,  self).__init__()
        self._atleast_ = None
        self._atleastnumber_ = None
        self._logicsymbol_ = None
        self._notmorethan_ = None
        self._notmorethannumber_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _atleast_ is not None:
            self.setAtleast(_atleast_)
        if _atleastnumber_ is not None:
            self.setAtleastnumber(_atleastnumber_)
        if _logicsymbol_ is not None:
            self.setLogicsymbol(_logicsymbol_)
        if _notmorethan_ is not None:
            self.setNotmorethan(_notmorethan_)
        if _notmorethannumber_ is not None:
            self.setNotmorethannumber(_notmorethannumber_)
        if _from_ is not None:
            self.setFrom(_from_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _selectlist_ is not None:
            self.setSelectlist(_selectlist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AAtleastnotmorethanSelectstatement2(self.cloneNode(self._atleast_),
                                                   self.cloneNode(self._atleastnumber_),
                                                   self.cloneNode(self._logicsymbol_),
                                                   self.cloneNode(self._notmorethan_),
                                                   self.cloneNode(self._notmorethannumber_),
                                                   self.cloneNode(self._from_),
                                                   self.cloneNode(self._l_par_),
                                                   self.cloneNode(self._selectlist_),
                                                   self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAAtleastnotmorethanSelectstatement2(self)

    def getAtleast(self):
        return self._atleast_

    def setAtleast(self,  node):
        if self._atleast_ is not None:
            self._atleast_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._atleast_ = node

    def getAtleastnumber(self):
        return self._atleastnumber_

    def setAtleastnumber(self,  node):
        if self._atleastnumber_ is not None:
            self._atleastnumber_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._atleastnumber_ = node

    def getLogicsymbol(self):
        return self._logicsymbol_

    def setLogicsymbol(self,  node):
        if self._logicsymbol_ is not None:
            self._logicsymbol_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._logicsymbol_ = node

    def getNotmorethan(self):
        return self._notmorethan_

    def setNotmorethan(self,  node):
        if self._notmorethan_ is not None:
            self._notmorethan_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._notmorethan_ = node

    def getNotmorethannumber(self):
        return self._notmorethannumber_

    def setNotmorethannumber(self,  node):
        if self._notmorethannumber_ is not None:
            self._notmorethannumber_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._notmorethannumber_ = node

    def getFrom(self):
        return self._from_

    def setFrom(self,  node):
        if self._from_ is not None:
            self._from_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._from_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getSelectlist(self):
        return self._selectlist_

    def setSelectlist(self,  node):
        if self._selectlist_ is not None:
            self._selectlist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._selectlist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._atleast_) + self.toString(self._atleastnumber_) \
               + self.toString(self._logicsymbol_) + self.toString(self._notmorethan_) \
               + self.toString(self._notmorethannumber_) + self.toString(self._from_) \
               + self.toString(self._l_par_) + self.toString(self._selectlist_) \
               + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._atleast_ == child:
            self._atleast_ = None
            return
        if self._atleastnumber_ == child:
            self._atleastnumber_ = None
            return
        if self._logicsymbol_ == child:
            self._logicsymbol_ = None
            return
        if self._notmorethan_ == child:
            self._notmorethan_ = None
            return
        if self._notmorethannumber_ == child:
            self._notmorethannumber_ = None
            return
        if self._from_ == child:
            self._from_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._selectlist_ == child:
            self._selectlist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._atleast_ == oldChild:
            self.setAtleast(newChild)
            return
        if self._atleastnumber_ == oldChild:
            self.setAtleastnumber(newChild)
            return
        if self._logicsymbol_ == oldChild:
            self.setLogicsymbol(newChild)
            return
        if self._notmorethan_ == oldChild:
            self.setNotmorethan(newChild)
            return
        if self._notmorethannumber_ == oldChild:
            self.setNotmorethannumber(newChild)
            return
        if self._from_ == oldChild:
            self.setFrom(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._selectlist_ == oldChild:
            self.setSelectlist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class ASelectlist(Node):
    def __init__(self,  _residue_=None, _listitems_=None):
        super(ASelectlist,  self).__init__()
        self._residue_ = None
        self._listitems_ = list()
        if _residue_ is not None:
            self.setResidue(_residue_)
        if _listitems_ is not None:
            self._listitems_.extend(_listitems_)

    def clone(self):
        return ASelectlist(self.cloneNode(self._residue_), self.cloneList(self._listitems_))

    def apply(self,  analysis):
        analysis.caseASelectlist(self)

    def getResidue(self):
        return self._residue_

    def setResidue(self,  node):
        if self._residue_ is not None:
            self._residue_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._residue_ = node

    def getListitems(self):
        return self._listitems_

    def setListitems(self,  lst):
        del self._listitems_[0:len(self._listitems_)]
        self._listitems_.extend(lst)

    def __str__(self):
        return '' + self.toString(self._residue_) + self.toString(self._listitems_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._residue_ == child:
            self._residue_ = None
            return
        if child in self._listitems_:
            self._listitems_.remove(child)
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._residue_ == oldChild:
            self.setResidue(newChild)
            return
        for i in range(self._listitems_):
            if self._listitems_[i] == oldChild:
                if newChild is not None:
                    self._listitems_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._listitems_[i]
                oldChild.setparent(None)
                return


class AListitems(Node):
    def __init__(self,  _comma_=None, _residue_=None):
        super(AListitems,  self).__init__()
        self._comma_ = None
        self._residue_ = None
        if _comma_ is not None:
            self.setComma(_comma_)
        if _residue_ is not None:
            self.setResidue(_residue_)

    def clone(self):
        return AListitems(self.cloneNode(self._comma_), self.cloneNode(self._residue_))

    def apply(self,  analysis):
        analysis.caseAListitems(self)

    def getComma(self):
        return self._comma_

    def setComma(self,  node):
        if self._comma_ is not None:
            self._comma_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._comma_ = node

    def getResidue(self):
        return self._residue_

    def setResidue(self,  node):
        if self._residue_ is not None:
            self._residue_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.toString(self._comma_) + self.toString(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._comma_ == child:
            self._comma_ = None
            return
        if self._residue_ == child:
            self._residue_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._comma_ == oldChild:
            self.setComma(newChild)
            return
        if self._residue_ == oldChild:
            self.setResidue(newChild)
            return


class AScorecondition(Node):
    def __init__(self,  _score_=None, _from_=None, _l_par_=None, _scorelist_=None, _r_par_=None):
        super(AScorecondition,  self).__init__()
        self._score_ = None
        self._from_ = None
        self._l_par_ = None
        self._scorelist_ = None
        self._r_par_ = None
        if _score_ is not None:
            self.setScore(_score_)
        if _from_ is not None:
            self.setFrom(_from_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _scorelist_ is not None:
            self.setScorelist(_scorelist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AScorecondition(self.cloneNode(self._score_), self.cloneNode(self._from_),
                               self.cloneNode(self._l_par_), self.cloneNode(self._scorelist_),
                               self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAScorecondition(self)

    def getScore(self):
        return self._score_

    def setScore(self,  node):
        if self._score_ is not None:
            self._score_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._score_ = node

    def getFrom(self):
        return self._from_

    def setFrom(self,  node):
        if self._from_ is not None:
            self._from_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._from_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getScorelist(self):
        return self._scorelist_

    def setScorelist(self,  node):
        if self._scorelist_ is not None:
            self._scorelist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._scorelist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._score_) + self.toString(self._from_) \
               + self.toString(self._l_par_) + self.toString(self._scorelist_) \
               + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._score_ == child:
            self._score_ = None
            return
        if self._from_ == child:
            self._from_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._scorelist_ == child:
            self._scorelist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._score_ == oldChild:
            self.setScore(newChild)
            return
        if self._from_ == oldChild:
            self.setFrom(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._scorelist_ == oldChild:
            self.setScorelist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AScorelist(Node):
    def __init__(self,  _scoreitem_=None, _scoreitems_=None):
        super(AScorelist,  self).__init__()
        self._scoreitem_ = None
        self._scoreitems_ = list()
        if _scoreitem_ is not None:
            self.setScoreitem(_scoreitem_)
        if _scoreitems_ is not None:
            self._scoreitems_.extend(_scoreitems_)

    def clone(self):
        return AScorelist(self.cloneNode(self._scoreitem_), self.cloneList(self._scoreitems_))

    def apply(self,  analysis):
        analysis.caseAScorelist(self)

    def getScoreitem(self):
        return self._scoreitem_

    def setScoreitem(self,  node):
        if self._scoreitem_ is not None:
            self._scoreitem_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._scoreitem_ = node

    def getScoreitems(self):
        return self._scoreitems_

    def setScoreitems(self,  lst):
        del self._scoreitems_[0:len(self._scoreitems_)]
        self._scoreitems_.extend(lst)

    def __str__(self):
        return '' + self.toString(self._scoreitem_) + self.toString(self._scoreitems_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._scoreitem_ == child:
            self._scoreitem_ = None
            return
        if child in self._scoreitems_:
            self._scoreitems_.remove(child)
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._scoreitem_ == oldChild:
            self.setScoreitem(newChild)
            return
        for i in range(self._scoreitems_):
            if self._scoreitems_[i] == oldChild:
                if newChild is not None:
                    self._scoreitems_[i] = newChild
                    oldChild.setparent(None)
                    return

                del self._scoreitems_[i]
                oldChild.setparent(None)
                return


class AStatementScoreitem(Node):
    def __init__(self,  _booleancondition_=None, _mapper_=None, _min_=None, _number_=None):
        super(AStatementScoreitem,  self).__init__()
        self._booleancondition_ = None
        self._mapper_ = None
        self._min_ = None
        self._number_ = None
        if _booleancondition_ is not None:
            self.setBooleancondition(_booleancondition_)
        if _mapper_ is not None:
            self.setMapper(_mapper_)
        if _min_ is not None:
            self.setMin(_min_)
        if _number_ is not None:
            self.setNumber(_number_)

    def clone(self):
        return AStatementScoreitem(self.cloneNode(self._booleancondition_),
                                   self.cloneNode(self._mapper_), self.cloneNode(self._min_),
                                   self.cloneNode(self._number_))

    def apply(self,  analysis):
        analysis.caseAStatementScoreitem(self)

    def getBooleancondition(self):
        return self._booleancondition_

    def setBooleancondition(self,  node):
        if self._booleancondition_ is not None:
            self._booleancondition_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._booleancondition_ = node

    def getMapper(self):
        return self._mapper_

    def setMapper(self,  node):
        if self._mapper_ is not None:
            self._mapper_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._mapper_ = node

    def getMin(self):
        return self._min_

    def setMin(self,  node):
        if self._min_ is not None:
            self._min_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._min_ = node

    def getNumber(self):
        return self._number_

    def setNumber(self,  node):
        if self._number_ is not None:
            self._number_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._number_ = node

    def __str__(self):
        return '' + self.toString(self._booleancondition_) + self.toString(self._mapper_) \
               + self.toString(self._min_) + self.toString(self._number_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._booleancondition_ == child:
            self._booleancondition_ = None
            return
        if self._mapper_ == child:
            self._mapper_ = None
            return
        if self._min_ == child:
            self._min_ = None
            return
        if self._number_ == child:
            self._number_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._booleancondition_ == oldChild:
            self.setBooleancondition(newChild)
            return
        if self._mapper_ == oldChild:
            self.setMapper(newChild)
            return
        if self._min_ == oldChild:
            self.setMin(newChild)
            return
        if self._number_ == oldChild:
            self.setNumber(newChild)
            return


class AMaxScoreitem(Node):
    def __init__(self,  _max_=None, _l_par_=None, _scorelist_=None, _r_par_=None):
        super(AMaxScoreitem,  self).__init__()
        self._max_ = None
        self._l_par_ = None
        self._scorelist_ = None
        self._r_par_ = None
        if _max_ is not None:
            self.setMax(_max_)
        if _l_par_ is not None:
            self.setLPar(_l_par_)
        if _scorelist_ is not None:
            self.setScorelist(_scorelist_)
        if _r_par_ is not None:
            self.setRPar(_r_par_)

    def clone(self):
        return AMaxScoreitem(self.cloneNode(self._max_), self.cloneNode(self._l_par_),
                             self.cloneNode(self._scorelist_), self.cloneNode(self._r_par_))

    def apply(self,  analysis):
        analysis.caseAMaxScoreitem(self)

    def getMax(self):
        return self._max_

    def setMax(self,  node):
        if self._max_ is not None:
            self._max_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._max_ = node

    def getLPar(self):
        return self._l_par_

    def setLPar(self,  node):
        if self._l_par_ is not None:
            self._l_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._l_par_ = node

    def getScorelist(self):
        return self._scorelist_

    def setScorelist(self,  node):
        if self._scorelist_ is not None:
            self._scorelist_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._scorelist_ = node

    def getRPar(self):
        return self._r_par_

    def setRPar(self,  node):
        if self._r_par_ is not None:
            self._r_par_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.toString(self._max_) + self.toString(self._l_par_) \
               + self.toString(self._scorelist_) + self.toString(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._max_ == child:
            self._max_ = None
            return
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._scorelist_ == child:
            self._scorelist_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._max_ == oldChild:
            self.setMax(newChild)
            return
        if self._l_par_ == oldChild:
            self.setLPar(newChild)
            return
        if self._scorelist_ == oldChild:
            self.setScorelist(newChild)
            return
        if self._r_par_ == oldChild:
            self.setRPar(newChild)
            return


class AScoreitems(Node):
    def __init__(self,  _comma_=None, _scoreitem_=None):
        super(AScoreitems,  self).__init__()
        self._comma_ = None
        self._scoreitem_ = None
        if _comma_ is not None:
            self.setComma(_comma_)
        if _scoreitem_ is not None:
            self.setScoreitem(_scoreitem_)

    def clone(self):
        return AScoreitems(self.cloneNode(self._comma_), self.cloneNode(self._scoreitem_))

    def apply(self,  analysis):
        analysis.caseAScoreitems(self)

    def getComma(self):
        return self._comma_

    def setComma(self,  node):
        if self._comma_ is not None:
            self._comma_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._comma_ = node

    def getScoreitem(self):
        return self._scoreitem_

    def setScoreitem(self,  node):
        if self._scoreitem_ is not None:
            self._scoreitem_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._scoreitem_ = node

    def __str__(self):
        return '' + self.toString(self._comma_) + self.toString(self._scoreitem_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._comma_ == child:
            self._comma_ = None
            return
        if self._scoreitem_ == child:
            self._scoreitem_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._comma_ == oldChild:
            self.setComma(newChild)
            return
        if self._scoreitem_ == oldChild:
            self.setScoreitem(newChild)
            return


class AIntegerNumber(Node):
    def __init__(self,  _integer_=None):
        super(AIntegerNumber,  self).__init__()
        self._integer_ = None
        if _integer_ is not None:
            self.setInteger(_integer_)

    def clone(self):
        return AIntegerNumber(self.cloneNode(self._integer_))

    def apply(self,  analysis):
        analysis.caseAIntegerNumber(self)

    def getInteger(self):
        return self._integer_

    def setInteger(self,  node):
        if self._integer_ is not None:
            self._integer_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._integer_ = node

    def __str__(self):
        return '' + self.toString(self._integer_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._integer_ == child:
            self._integer_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._integer_ == oldChild:
            self.setInteger(newChild)
            return


class AFloatNumber(Node):
    def __init__(self,  _float_=None):
        super(AFloatNumber,  self).__init__()
        self._float_ = None
        if _float_ is not None:
            self.setFloat(_float_)

    def clone(self):
        return AFloatNumber(self.cloneNode(self._float_))

    def apply(self,  analysis):
        analysis.caseAFloatNumber(self)

    def getFloat(self):
        return self._float_

    def setFloat(self,  node):
        if self._float_ is not None:
            self._float_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._float_ = node

    def __str__(self):
        return '' + self.toString(self._float_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def removeChild(self,  child):
        if self._float_ == child:
            self._float_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._float_ == oldChild:
            self.setFloat(newChild)
            return


class Start(Node):
    def __init__(self,  _base_=None,  _eof_=None):
        super(Start,  self).__init__()
        self._base_ = None
        self._eof_ = None
        self.setPStatement(_base_)
        self.setEOF(_eof_)

    def clone(self):
        return Start(self.cloneNode(self._base_),  self.cloneNode(self._eof_))

    def apply(self,  analysis):
        analysis.caseStart(self)

    def getPStatement(self):
        return self._base_

    def setPStatement(self,  node):
        if self._base_ is not None:
            self._base_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._base_ = node

    def getEOF(self):
        return self._eof_

    def setEOF(self,  node):
        if self._eof_ is not None:
            self._eof_.setparent(None)

        if node is not None:
            if node.getparent() is not None:
                node.getparent().removeChild(node)

            node.setparent(self)

        self._eof_ = node

    def removeChild(self,  child):
        if self._base_ == child:
            self._base_ = None
            return

        if self._eof_ == child:
            self._eof_ = None
            return

    def replaceChild(self,  oldChild,  newChild):
        if self._base_ == oldChild:
            self.setPStatement(newChild)
            return

        if self._eof_ == oldChild:
            self.setEOF(newChild)
            return

    def __str__(self):
        return '' + self.toString(self._base_) + self.toString(self._eof_)

    def __repr__(self):
        return "'" + self.__str__() + "'"
