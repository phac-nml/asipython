"""
Copyright Government of Canada 2018

Written by: Eric Enns, National Microbiology Laboratory, Public Health Agency of Canada

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this work except in compliance with the License. You may obtain a copy of the
License at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
"""
# This file was generated by SableCC (http://www.sablecc.org/).
# pylint: disable=missing-docstring

from Asi.Grammar.Node import EOF, TAminoAcid, TAnd, TAtleast, TBlank, TComma, TExactly, \
                             TExclude, TFloat, TFrom, TInteger, TLPar, TMapper, TMax, TMin, \
                             TNot, TNotmorethan, TOr, TRPar, TScore, TSelect
from Asi.Grammar.utils import PushbackReader, StringBuffer


class LexerException(Exception):
    def __init__(self, value):
        super().__init__()
        self.value = value

    def __str__(self):
        return self.value


# lexer states
STATE_INITIAL = 0

ACCEPT_TOKENS = [
    TMin,
    TAnd,
    TOr,
    TNot,
    TExclude,
    TSelect,
    TFrom,
    TAtleast,
    TExactly,
    TNotmorethan,
    TScore,
    TMax,
    TLPar,
    TRPar,
    TMapper,
    TComma,
    lambda line, pos: TBlank(None, line, pos),
    lambda line, pos: TInteger(None, line, pos),
    lambda line, pos: TFloat(None, line, pos),
    lambda line, pos: TAminoAcid(None, line, pos),
]


LEXER_GO_TO_TABLE = [
    [
        [
            [9, 9, 1],
            [10, 10, 2],
            [13, 13, 3],
            [32, 32, 4],
            [40, 40, 5],
            [41, 41, 6],
            [44, 44, 7],
            [45, 45, 8],
            [48, 57, 9],
            [61, 61, 10],
            [65, 65, 11],
            [67, 67, 12],
            [68, 68, 13],
            [69, 69, 14],
            [70, 70, 15],
            [71, 71, 16],
            [72, 72, 17],
            [73, 73, 18],
            [75, 75, 19],
            [76, 76, 20],
            [77, 77, 21],
            [78, 78, 22],
            [79, 79, 23],
            [80, 80, 24],
            [81, 81, 25],
            [82, 82, 26],
            [83, 83, 27],
            [84, 84, 28],
            [86, 86, 29],
            [87, 87, 30],
            [89, 89, 31],
            [90, 90, 32],
            [100, 100, 33],
            [105, 105, 34],
        ],
        [
            [9, 32, -2],
        ],
        [
            [9, 32, -2],
        ],
        [
            [9, 32, -2],
        ],
        [
            [9, 32, -2],
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
            [46, 46, 35],
            [48, 57, 9],
        ],
        [
            [62, 62, 36],
        ],
        [
            [78, 78, 37],
            [84, 84, 38],
        ],
        [
        ],
        [
        ],
        [
            [88, 88, 39],
        ],
        [
            [82, 82, 40],
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
            [65, 65, 41],
        ],
        [
            [79, 79, 42],
        ],
        [
            [82, 82, 43],
        ],
        [
        ],
        [
        ],
        [
        ],
        [
            [67, 67, 44],
            [69, 69, 45],
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
            [48, 57, 46],
        ],
        [
        ],
        [
            [68, 68, 47],
        ],
        [
            [76, 76, 48],
        ],
        [
            [65, 65, 49],
            [67, 67, 50],
        ],
        [
            [79, 79, 51],
        ],
        [
            [88, 88, 52],
        ],
        [
            [84, 84, 53],
        ],
        [
        ],
        [
            [79, 79, 54],
        ],
        [
            [76, 76, 55],
        ],
        [
            [48, 57, 46],
        ],
        [
        ],
        [
            [69, 69, 56],
        ],
        [
            [67, 67, 57],
        ],
        [
            [76, 76, 58],
        ],
        [
            [77, 77, 59],
        ],
        [
        ],
        [
            [77, 77, 60],
        ],
        [
            [82, 82, 61],
        ],
        [
            [69, 69, 62],
        ],
        [
            [65, 65, 63],
        ],
        [
            [84, 84, 64],
        ],
        [
            [85, 85, 65],
        ],
        [
        ],
        [
            [79, 79, 66],
        ],
        [
            [69, 69, 67],
        ],
        [
            [67, 67, 68],
        ],
        [
            [83, 83, 69],
        ],
        [
            [76, 76, 70],
        ],
        [
            [68, 68, 71],
        ],
        [
            [82, 82, 72],
        ],
        [
        ],
        [
            [84, 84, 73],
        ],
        [
            [84, 84, 74],
        ],
        [
            [89, 89, 75],
        ],
        [
            [69, 69, 76],
        ],
        [
            [69, 69, 77],
        ],
        [
        ],
        [
        ],
        [
        ],
        [
        ],
        [
            [84, 84, 78],
        ],
        [
            [72, 72, 79],
        ],
        [
            [65, 65, 80],
        ],
        [
            [78, 78, 81],
        ],
        [
        ],
    ],
]

ACCEPT_TABLE = [
    [
        -1, 16, 16, 16, 16, 12, 13, 15, 0, 17, -1, 19, 19, 19, 19,
        19, 19, 19, 19, 19, 19, 19, 19, -1, 19, 19, 19, 19, 19, 19,
        19, 19, 19, 19, 19, -1, 14, -1, -1, -1, -1, -1, -1, 2, -1,
        -1, 18, 1, -1, -1, -1, -1, 11, 3, -1, -1, -1, -1, -1, 6, -1,
        -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, 5, 7, 8, 4,
        -1, -1, -1, -1, 9,
    ],
]


# pylint: disable=too-many-instance-attributes
class Lexer:
    def __init__(self, source):
        if isinstance(source, bytes):
            self.reader = PushbackReader(open(source, "r"))
        else:
            self.reader = PushbackReader(source)

        self.token = None
        self.state = STATE_INITIAL
        self.line = 0
        self.pos = 0
        self.crtrn = False
        self.eof = False
        self.text = StringBuffer()

    def filter(self):
        pass

    def peek(self):
        while self.token is None:
            self.token = self.get_token()
            self.filter()
        return self.token

    def next(self):
        while self.token is None:
            self.token = self.get_token()
            self.filter()

        result = self.token
        self.token = None
        return result

    # pylint: disable=too-many-locals,too-many-branches,too-many-statements
    def get_token(self):
        dfa_state = 0

        start_pos = self.pos
        start_line = self.line

        accept_state = -1
        accept_token = -1
        accept_length = -1
        accept_pos = -1
        accept_line = -1
        go_to_table = LEXER_GO_TO_TABLE[self.state]
        accept = ACCEPT_TABLE[self.state]
        text = self.text
        text.clear()

        while True:
            char = self.get_char()

            if char != -1:
                if char == 10:
                    if self.crtrn:
                        self.crtrn = False
                    else:
                        self.line = self.line + 1
                        self.pos = 0
                elif char == 13:
                    self.line = self.line + 1
                    self.pos = 0
                    self.crtrn = True
                else:
                    self.pos = self.pos + 1
                    self.crtrn = False

                text.append(chr(char))

                while True:
                    if dfa_state < -1:
                        old_state = -2 - dfa_state
                    else:
                        old_state = dfa_state

                    dfa_state = -1

                    tmp1 = go_to_table[old_state]
                    low = 0
                    high = len(tmp1) - 1

                    while low <= high:
                        middle = (int)((low + high) / 2)
                        tmp2 = tmp1[middle]

                        if char < tmp2[0]:
                            high = middle - 1
                        elif char > tmp2[1]:
                            low = middle + 1
                        else:
                            dfa_state = tmp2[2]
                            break
                    if dfa_state >= -1:
                        break
            else:
                dfa_state = -1

            if dfa_state >= 0:
                if accept[dfa_state] != -1:
                    accept_state = dfa_state
                    accept_token = accept[dfa_state]
                    accept_length = len(text)
                    accept_pos = self.pos
                    accept_line = self.line
            else:
                if accept_state != -1:
                    # pylint: disable=chained-comparison
                    if accept_token >= 0 and accept_token <= 19:
                        token = ACCEPT_TOKENS[accept_token](start_line + 1, start_pos + 1)
                        if token.get_text() is None:
                            token.set_text(self.get_text(accept_length))

                        self.push_back(accept_length)
                        self.pos = accept_pos
                        self.line = accept_line

                        return token
                else:
                    if text:
                        raise LexerException("[" + str(start_line + 1) + ","
                                             + str(start_pos + 1) + "]"
                                             + " Unknown token: " + str(text))
                    else:
                        return EOF(start_line + 1, start_pos + 1)

    def get_char(self):
        if self.eof:
            return -1
        char = self.reader.read()

        if char == "":
            result = -1
        else:
            result = ord(char)

        if result == -1:
            self.eof = True

        return result

    def push_back(self, accept_length):
        text = self.text
        length = len(text)
        for i in range(length - 1, accept_length - 1, -1):
            self.eof = False
            self.reader.unread(text.char_at(i))

    def unread(self, token):
        text = token.get_text()
        length = len(text)

        for i in range(length-1, -1, -1):
            self.eof = False
            self.reader.unread(text[i])

        self.pos = token.get_pos() - 1
        self.line = token.get_line() - 1

    def get_text(self, accept_length):
        string_buffer = StringBuffer()
        text = self.text
        for i in range(accept_length):
            string_buffer.append(text.char_at(i))

        return str(string_buffer)
