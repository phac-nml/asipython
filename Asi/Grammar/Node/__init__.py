"""
Copyright Government of Canada 2018

Written by: Eric Enns, National Microbiology Laboratory, Public Health Agency of Canada

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this work except in compliance with the License. You may obtain a copy of the
License at:

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
"""
# This file was generated by SableCC (http://www.sablecc.org/).
# pylint: disable=too-many-lines,missing-docstring

from Asi.Grammar.utils import StringBuffer, abstract


class Node:
    def __init__(self):
        if self.__class__ is Node:
            raise TypeError("Node class can not be instantiated.")
        self.parent = None

    def clone(self):
        abstract(self)

    def get_parent(self):
        return self.parent

    def set_parent(self, parent):
        self.parent = parent

    def remove_child(self, child):
        abstract(self, child)

    def replace_child(self, old_child, new_child):
        abstract(self, old_child, new_child)

    def replace_by(self, node):
        if self.parent is not None:
            self.parent.replace_child(self, node)

    @classmethod
    def to_string(cls, other):
        if isinstance(other, list):
            string_buffer = StringBuffer()

            for node in other:
                string_buffer.append(node)

            return str(string_buffer)

        if other is not None:
            return str(other)

        return ''

    @classmethod
    def clone_node(cls, node):
        if node is not None:
            return node.clone()

        return None

    @classmethod
    def clone_list(cls, lst):
        clone = list()

        for node in lst:
            clone.append(node.clone())

        return clone

    def apply(self, analysis):
        abstract(self, analysis)


class Token(Node):
    def __init__(self):
        super(Token, self).__init__()
        self.text = None
        self.line = 0
        self.pos = 0

    def get_text(self):
        return self.text

    def set_text(self, text):
        self.text = text

    def get_line(self):
        return self.line

    def set_line(self, line):
        self.line = line

    def get_pos(self):
        return self.pos

    def set_pos(self, pos):
        self.pos = pos

    def __str__(self):
        return self.text + " "

    def remove_child(self, child):
        pass

    def replace_child(self, old_child, new_child):
        pass


class TMin(Token):
    TokenIndex = 0

    def __init__(self, line=0, pos=0):
        super(TMin, self).__init__()
        super(TMin, self).set_text("-")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TMin(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tmin(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TMin text.")


class TAnd(Token):
    TokenIndex = 1

    def __init__(self, line=0, pos=0):
        super(TAnd, self).__init__()
        super(TAnd, self).set_text("AND")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TAnd(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tand(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TAnd text.")


class TOr(Token):
    TokenIndex = 2

    def __init__(self, line=0, pos=0):
        super(TOr, self).__init__()
        super(TOr, self).set_text("OR")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TOr(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tor(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TOr text.")


class TNot(Token):
    TokenIndex = 3

    def __init__(self, line=0, pos=0):
        super(TNot, self).__init__()
        super(TNot, self).set_text("NOT")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TNot(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tnot(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TNot text.")


class TExclude(Token):
    TokenIndex = 4

    def __init__(self, line=0, pos=0):
        super(TExclude, self).__init__()
        super(TExclude, self).set_text("EXCLUDE")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TExclude(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_texclude(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TExclude text.")


class TSelect(Token):
    TokenIndex = 5

    def __init__(self, line=0, pos=0):
        super(TSelect, self).__init__()
        super(TSelect, self).set_text("SELECT")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TSelect(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tselect(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TSelect text.")


class TFrom(Token):
    TokenIndex = 6

    def __init__(self, line=0, pos=0):
        super(TFrom, self).__init__()
        super(TFrom, self).set_text("FROM")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TFrom(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tfrom(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TFrom text.")


class TAtleast(Token):
    TokenIndex = 7

    def __init__(self, line=0, pos=0):
        super(TAtleast, self).__init__()
        super(TAtleast, self).set_text("ATLEAST")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TAtleast(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tatleast(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TAtleast text.")


class TExactly(Token):
    TokenIndex = 8

    def __init__(self, line=0, pos=0):
        super(TExactly, self).__init__()
        super(TExactly, self).set_text("EXACTLY")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TExactly(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_texactly(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TExactly text.")


class TNotmorethan(Token):
    TokenIndex = 9

    def __init__(self, line=0, pos=0):
        super(TNotmorethan, self).__init__()
        super(TNotmorethan, self).set_text("NOTMORETHAN")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TNotmorethan(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tnotmorethan(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TNotmorethan text.")


class TScore(Token):
    TokenIndex = 10

    def __init__(self, line=0, pos=0):
        super(TScore, self).__init__()
        super(TScore, self).set_text("SCORE")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TScore(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tscore(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TScore text.")


class TMax(Token):
    TokenIndex = 11

    def __init__(self, line=0, pos=0):
        super(TMax, self).__init__()
        super(TMax, self).set_text("MAX")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TMax(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tmax(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TMax text.")


class TLPar(Token):
    TokenIndex = 12

    def __init__(self, line=0, pos=0):
        super(TLPar, self).__init__()
        super(TLPar, self).set_text("(")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TLPar(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tlpar(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TLPar text.")


class TRPar(Token):
    TokenIndex = 13

    def __init__(self, line=0, pos=0):
        super(TRPar, self).__init__()
        super(TRPar, self).set_text(")")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TRPar(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_trpar(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TRPar text.")


class TMapper(Token):
    TokenIndex = 14

    def __init__(self, line=0, pos=0):
        super(TMapper, self).__init__()
        super(TMapper, self).set_text("=>")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TMapper(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tmapper(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TMapper text.")


class TComma(Token):
    TokenIndex = 15

    def __init__(self, line=0, pos=0):
        super(TComma, self).__init__()
        super(TComma, self).set_text(", ")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TComma(self.get_line(), self.get_pos())

    def __copy__(self):
        return self.clone()

    def apply(self, analysis):
        analysis.case_tcomma(self)

    def set_text(self, text):
        raise RuntimeError("Cannot change TComma text.")


class TBlank(Token):
    TokenIndex = -1

    def __init__(self, text, line=0, pos=0):
        super(TBlank, self).__init__()
        self.set_text(text)
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TBlank(self.get_text(), self.get_line(), self.get_pos())

    def apply(self, analysis):
        analysis.case_tblank(self)


class TInteger(Token):
    TokenIndex = 16

    def __init__(self, text, line=0, pos=0):
        super(TInteger, self).__init__()
        self.set_text(text)
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TInteger(self.get_text(), self.get_line(), self.get_pos())

    def apply(self, analysis):
        analysis.case_tinteger(self)


class TFloat(Token):
    TokenIndex = 17

    def __init__(self, text, line=0, pos=0):
        super(TFloat, self).__init__()
        self.set_text(text)
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TFloat(self.get_text(), self.get_line(), self.get_pos())

    def apply(self, analysis):
        analysis.case_tfloat(self)


class TAminoAcid(Token):
    TokenIndex = 18

    def __init__(self, text, line=0, pos=0):
        super(TAminoAcid, self).__init__()
        self.set_text(text)
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return TAminoAcid(self.get_text(), self.get_line(), self.get_pos())

    def apply(self, analysis):
        analysis.case_taminoacid(self)


class EOF(Token):
    TokenIndex = 19

    def __init__(self, line=0, pos=0):
        super(EOF, self).__init__()
        self.set_text("")
        self.set_line(line)
        self.set_pos(pos)

    def clone(self):
        return EOF(self.get_line(), self.get_pos())

    def apply(self, analysis):
        analysis.case_eof(self)


class ALogicstatementStatement(Node):
    def __init__(self, _booleancondition_=None):
        super(ALogicstatementStatement, self).__init__()
        self._booleancondition_ = None
        if _booleancondition_ is not None:
            self.set_booleancondition(_booleancondition_)

    def clone(self):
        return ALogicstatementStatement(self.clone_node(self._booleancondition_))

    def apply(self, analysis):
        analysis.case_alogicstatementstatement(self)

    def get_booleancondition(self):
        return self._booleancondition_

    def set_booleancondition(self, node):
        if self._booleancondition_ is not None:
            self._booleancondition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._booleancondition_ = node

    def __str__(self):
        return '' + self.to_string(self._booleancondition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._booleancondition_ == child:
            self._booleancondition_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._booleancondition_ == old_child:
            self.set_booleancondition(new_child)
            return


class AScoreStatement(Node):
    def __init__(self, _scorecondition_=None):
        super(AScoreStatement, self).__init__()
        self._scorecondition_ = None
        if _scorecondition_ is not None:
            self.set_scorecondition(_scorecondition_)

    def clone(self):
        return AScoreStatement(self.clone_node(self._scorecondition_))

    def apply(self, analysis):
        analysis.case_ascorestatement(self)

    def get_scorecondition(self):
        return self._scorecondition_

    def set_scorecondition(self, node):
        if self._scorecondition_ is not None:
            self._scorecondition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._scorecondition_ = node

    def __str__(self):
        return '' + self.to_string(self._scorecondition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._scorecondition_ == child:
            self._scorecondition_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._scorecondition_ == old_child:
            self.set_scorecondition(new_child)
            return


class ABooleancondition(Node):
    def __init__(self, _condition_=None, _condition2_=None):
        super(ABooleancondition, self).__init__()
        self._condition_ = None
        self._condition2_ = list()
        if _condition_ is not None:
            self.set_condition(_condition_)
        if _condition2_ is not None:
            self._condition2_.extend(_condition2_)

    def clone(self):
        return ABooleancondition(self.clone_node(self._condition_),
                                 self.clone_list(self._condition2_))

    def apply(self, analysis):
        analysis.case_abooleancondition(self)

    def get_condition(self):
        return self._condition_

    def set_condition(self, node):
        if self._condition_ is not None:
            self._condition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._condition_ = node

    def get_condition2(self):
        return self._condition2_

    def set_condition2(self, lst):
        del self._condition2_[0:len(self._condition2_)]
        self._condition2_.extend(lst)

    def __str__(self):
        return '' + self.to_string(self._condition_) + self.to_string(self._condition2_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._condition_ == child:
            self._condition_ = None
            return
        if child in self._condition2_:
            self._condition2_.remove(child)
            return

    def replace_child(self, old_child, new_child):
        if self._condition_ == old_child:
            self.set_condition(new_child)
            return
        for i in range(self._condition2_):
            if self._condition2_[i] == old_child:
                if new_child is not None:
                    self._condition2_[i] = new_child
                    old_child.set_parent(None)
                    return

                del self._condition2_[i]
                old_child.set_parent(None)
                return


class AStatementCondition(Node):
    def __init__(self, _l_par_=None, _booleancondition_=None, _r_par_=None):
        super(AStatementCondition, self).__init__()
        self._l_par_ = None
        self._booleancondition_ = None
        self._r_par_ = None
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _booleancondition_ is not None:
            self.set_booleancondition(_booleancondition_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AStatementCondition(self.clone_node(self._l_par_),
                                   self.clone_node(self._booleancondition_),
                                   self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_astatementcondition(self)

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_booleancondition(self):
        return self._booleancondition_

    def set_booleancondition(self, node):
        if self._booleancondition_ is not None:
            self._booleancondition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._booleancondition_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._l_par_) + self.to_string(self._booleancondition_) \
               + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._l_par_ == child:
            self._l_par_ = None
            return
        if self._booleancondition_ == child:
            self._booleancondition_ = None
            return
        if self._r_par_ == child:
            self._r_par_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._l_par_ == old_child:
            self.set_lpar(new_child)
            return
        if self._booleancondition_ == old_child:
            self.set_booleancondition(new_child)
            return
        if self._r_par_ == old_child:
            self.set_rpar(new_child)
            return


class AResidueCondition(Node):
    def __init__(self, _residue_=None):
        super(AResidueCondition, self).__init__()
        self._residue_ = None
        if _residue_ is not None:
            self.set_residue(_residue_)

    def clone(self):
        return AResidueCondition(self.clone_node(self._residue_))

    def apply(self, analysis):
        analysis.case_aresiduecondition(self)

    def get_residue(self):
        return self._residue_

    def set_residue(self, node):
        if self._residue_ is not None:
            self._residue_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.to_string(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._residue_ == child:
            self._residue_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._residue_ == old_child:
            self.set_residue(new_child)
            return


class AExcludeCondition(Node):
    def __init__(self, _excludestatement_=None):
        super(AExcludeCondition, self).__init__()
        self._excludestatement_ = None
        if _excludestatement_ is not None:
            self.set_excludestatement(_excludestatement_)

    def clone(self):
        return AExcludeCondition(self.clone_node(self._excludestatement_))

    def apply(self, analysis):
        analysis.case_aexcludecondition(self)

    def get_excludestatement(self):
        return self._excludestatement_

    def set_excludestatement(self, node):
        if self._excludestatement_ is not None:
            self._excludestatement_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._excludestatement_ = node

    def __str__(self):
        return '' + self.to_string(self._excludestatement_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._excludestatement_ == child:
            self._excludestatement_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._excludestatement_ == old_child:
            self.set_excludestatement(new_child)
            return


class ASelectCondition(Node):
    def __init__(self, _selectstatement_=None):
        super(ASelectCondition, self).__init__()
        self._selectstatement_ = None
        if _selectstatement_ is not None:
            self.set_selectstatement(_selectstatement_)

    def clone(self):
        return ASelectCondition(self.clone_node(self._selectstatement_))

    def apply(self, analysis):
        analysis.case_aselectcondition(self)

    def get_selectstatement(self):
        return self._selectstatement_

    def set_selectstatement(self, node):
        if self._selectstatement_ is not None:
            self._selectstatement_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectstatement_ = node

    def __str__(self):
        return '' + self.to_string(self._selectstatement_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._selectstatement_ == child:
            self._selectstatement_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._selectstatement_ == old_child:
            self.set_selectstatement(new_child)
            return


class ACondition2(Node):
    def __init__(self, _logicsymbol_=None, _condition_=None):
        super(ACondition2, self).__init__()
        self._logicsymbol_ = None
        self._condition_ = None
        if _logicsymbol_ is not None:
            self.set_logicsymbol(_logicsymbol_)
        if _condition_ is not None:
            self.set_condition(_condition_)

    def clone(self):
        return ACondition2(self.clone_node(self._logicsymbol_), self.clone_node(self._condition_))

    def apply(self, analysis):
        analysis.case_acondition2(self)

    def get_logicsymbol(self):
        return self._logicsymbol_

    def set_logicsymbol(self, node):
        if self._logicsymbol_ is not None:
            self._logicsymbol_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._logicsymbol_ = node

    def get_condition(self):
        return self._condition_

    def set_condition(self, node):
        if self._condition_ is not None:
            self._condition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._condition_ = node

    def __str__(self):
        return '' + self.to_string(self._logicsymbol_) + self.to_string(self._condition_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._logicsymbol_ == child:
            self._logicsymbol_ = None
            return
        if self._condition_ == child:
            self._condition_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._logicsymbol_ == old_child:
            self.set_logicsymbol(new_child)
            return
        if self._condition_ == old_child:
            self.set_condition(new_child)
            return


class AAndLogicsymbol(Node):
    def __init__(self, _and_=None):
        super(AAndLogicsymbol, self).__init__()
        self._and_ = None
        if _and_ is not None:
            self.set_and(_and_)

    def clone(self):
        return AAndLogicsymbol(self.clone_node(self._and_))

    def apply(self, analysis):
        analysis.case_aandlogicsymbol(self)

    def get_and(self):
        return self._and_

    def set_and(self, node):
        if self._and_ is not None:
            self._and_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._and_ = node

    def __str__(self):
        return '' + self.to_string(self._and_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._and_ == child:
            self._and_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._and_ == old_child:
            self.set_and(new_child)
            return


class AOrLogicsymbol(Node):
    def __init__(self, _or_=None):
        super(AOrLogicsymbol, self).__init__()
        self._or_ = None
        if _or_ is not None:
            self.set_or(_or_)

    def clone(self):
        return AOrLogicsymbol(self.clone_node(self._or_))

    def apply(self, analysis):
        analysis.case_aorlogicsymbol(self)

    def get_or(self):
        return self._or_

    def set_or(self, node):
        if self._or_ is not None:
            self._or_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._or_ = node

    def __str__(self):
        return '' + self.to_string(self._or_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._or_ == child:
            self._or_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._or_ == old_child:
            self.set_or(new_child)
            return


class AResidueResidue(Node):
    def __init__(self, _originalaminoacid_=None, _integer_=None, _mutatedaminoacid_=None):
        super(AResidueResidue, self).__init__()
        self._originalaminoacid_ = None
        self._integer_ = None
        self._mutatedaminoacid_ = list()
        if _originalaminoacid_ is not None:
            self.set_originalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)

    def clone(self):
        return AResidueResidue(self.clone_node(self._originalaminoacid_),
                               self.clone_node(self._integer_),
                               self.clone_list(self._mutatedaminoacid_))

    def apply(self, analysis):
        analysis.case_aresidueresidue(self)

    def get_originalaminoacid(self):
        return self._originalaminoacid_

    def set_originalaminoacid(self, node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._originalaminoacid_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_mutatedaminoacid(self):
        return self._mutatedaminoacid_

    def set_mutatedaminoacid(self, lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def __str__(self):
        return '' + self.to_string(self._originalaminoacid_) + self.to_string(self._integer_) \
               + self.to_string(self._mutatedaminoacid_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
            return

    def replace_child(self, old_child, new_child):
        if self._originalaminoacid_ == old_child:
            self.set_originalaminoacid(new_child)
            return
        if self._integer_ == old_child:
            self.set_integer(new_child)
            return
        for i in range(self._mutatedaminoacid_):
            if self._mutatedaminoacid_[i] == old_child:
                if new_child is not None:
                    self._mutatedaminoacid_[i] = new_child
                    old_child.set_parent(None)
                    return

                del self._mutatedaminoacid_[i]
                old_child.set_parent(None)
                return


class AResiduenotResidue(Node):
    def __init__(self, _not_=None, _originalaminoacid_=None, _integer_=None,
                 _mutatedaminoacid_=None):
        super(AResiduenotResidue, self).__init__()
        self._not_ = None
        self._originalaminoacid_ = None
        self._integer_ = None
        self._mutatedaminoacid_ = list()
        if _not_ is not None:
            self.set_not(_not_)
        if _originalaminoacid_ is not None:
            self.set_originalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)

    def clone(self):
        return AResiduenotResidue(self.clone_node(self._not_),
                                  self.clone_node(self._originalaminoacid_),
                                  self.clone_node(self._integer_),
                                  self.clone_list(self._mutatedaminoacid_))

    def apply(self, analysis):
        analysis.case_aresiduenotresidue(self)

    def get_not(self):
        return self._not_

    def set_not(self, node):
        if self._not_ is not None:
            self._not_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._not_ = node

    def get_originalaminoacid(self):
        return self._originalaminoacid_

    def set_originalaminoacid(self, node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._originalaminoacid_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_mutatedaminoacid(self):
        return self._mutatedaminoacid_

    def set_mutatedaminoacid(self, lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def __str__(self):
        return '' + self.to_string(self._not_) + self.to_string(self._originalaminoacid_) \
               + self.to_string(self._integer_) + self.to_string(self._mutatedaminoacid_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._not_ == child:
            self._not_ = None
            return
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
            return
        if self._integer_ == child:
            self._integer_ = None
            return
        if child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
            return

    def replace_child(self, old_child, new_child):
        if self._not_ == old_child:
            self.set_not(new_child)
            return
        if self._originalaminoacid_ == old_child:
            self.set_originalaminoacid(new_child)
            return
        if self._integer_ == old_child:
            self.set_integer(new_child)
            return
        for i in range(self._mutatedaminoacid_):
            if self._mutatedaminoacid_[i] == old_child:
                if new_child is not None:
                    self._mutatedaminoacid_[i] = new_child
                    old_child.set_parent(None)
                    return

                del self._mutatedaminoacid_[i]
                old_child.set_parent(None)
                return


class AResidueinvertResidue(Node):
    def __init__(self, _originalaminoacid_=None, _integer_=None, _l_par_=None, _not_=None,
                 _mutatedaminoacid_=None, _r_par_=None):
        super(AResidueinvertResidue, self).__init__()
        self._originalaminoacid_ = None
        self._integer_ = None
        self._l_par_ = None
        self._not_ = None
        self._mutatedaminoacid_ = list()
        self._r_par_ = None
        if _originalaminoacid_ is not None:
            self.set_originalaminoacid(_originalaminoacid_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _not_ is not None:
            self.set_not(_not_)
        if _mutatedaminoacid_ is not None:
            self._mutatedaminoacid_.extend(_mutatedaminoacid_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AResidueinvertResidue(self.clone_node(self._originalaminoacid_),
                                     self.clone_node(self._integer_),
                                     self.clone_node(self._l_par_),
                                     self.clone_node(self._not_),
                                     self.clone_list(self._mutatedaminoacid_),
                                     self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_aresidueinvertresidue(self)

    def get_originalaminoacid(self):
        return self._originalaminoacid_

    def set_originalaminoacid(self, node):
        if self._originalaminoacid_ is not None:
            self._originalaminoacid_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._originalaminoacid_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_not(self):
        return self._not_

    def set_not(self, node):
        if self._not_ is not None:
            self._not_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._not_ = node

    def get_mutatedaminoacid(self):
        return self._mutatedaminoacid_

    def set_mutatedaminoacid(self, lst):
        del self._mutatedaminoacid_[0:len(self._mutatedaminoacid_)]
        self._mutatedaminoacid_.extend(lst)

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._originalaminoacid_) + self.to_string(self._integer_) \
               + self.to_string(self._l_par_) + self.to_string(self._not_) \
               + self.to_string(self._mutatedaminoacid_) + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._originalaminoacid_ == child:
            self._originalaminoacid_ = None
        elif self._integer_ == child:
            self._integer_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._not_ == child:
            self._not_ = None
        elif child in self._mutatedaminoacid_:
            self._mutatedaminoacid_.remove(child)
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._originalaminoacid_ == old_child:
            self.set_originalaminoacid(new_child)
        elif self._integer_ == old_child:
            self.set_integer(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._not_ == old_child:
            self.set_not(new_child)
        else:
            for i in range(self._mutatedaminoacid_):
                if self._mutatedaminoacid_[i] == old_child:
                    if new_child is not None:
                        self._mutatedaminoacid_[i] = new_child
                        old_child.set_parent(None)
                        return

                    del self._mutatedaminoacid_[i]
                    old_child.set_parent(None)
                    return
        if self._r_par_ == old_child:
            self.set_rpar(new_child)


class AExcludestatement(Node):
    def __init__(self, _exclude_=None, _residue_=None):
        super(AExcludestatement, self).__init__()
        self._exclude_ = None
        self._residue_ = None
        if _exclude_ is not None:
            self.set_exclude(_exclude_)
        if _residue_ is not None:
            self.set_residue(_residue_)

    def clone(self):
        return AExcludestatement(self.clone_node(self._exclude_), self.clone_node(self._residue_))

    def apply(self, analysis):
        analysis.case_aexcludestatement(self)

    def get_exclude(self):
        return self._exclude_

    def set_exclude(self, node):
        if self._exclude_ is not None:
            self._exclude_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._exclude_ = node

    def get_residue(self):
        return self._residue_

    def set_residue(self, node):
        if self._residue_ is not None:
            self._residue_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.to_string(self._exclude_) + self.to_string(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._exclude_ == child:
            self._exclude_ = None
        elif self._residue_ == child:
            self._residue_ = None

    def replace_child(self, old_child, new_child):
        if self._exclude_ == old_child:
            self.set_exclude(new_child)
        elif self._residue_ == old_child:
            self.set_residue(new_child)


class ASelectstatement(Node):
    def __init__(self, _select_=None, _selectstatement2_=None):
        super(ASelectstatement, self).__init__()
        self._select_ = None
        self._selectstatement2_ = None
        if _select_ is not None:
            self.set_select(_select_)
        if _selectstatement2_ is not None:
            self.set_selectstatement2(_selectstatement2_)

    def clone(self):
        return ASelectstatement(self.clone_node(self._select_),
                                self.clone_node(self._selectstatement2_))

    def apply(self, analysis):
        analysis.case_aselectstatement(self)

    def get_select(self):
        return self._select_

    def set_select(self, node):
        if self._select_ is not None:
            self._select_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._select_ = node

    def get_selectstatement2(self):
        return self._selectstatement2_

    def set_selectstatement2(self, node):
        if self._selectstatement2_ is not None:
            self._selectstatement2_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectstatement2_ = node

    def __str__(self):
        return '' + self.to_string(self._select_) + self.to_string(self._selectstatement2_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._select_ == child:
            self._select_ = None
        elif self._selectstatement2_ == child:
            self._selectstatement2_ = None

    def replace_child(self, old_child, new_child):
        if self._select_ == old_child:
            self.set_select(new_child)
        elif self._selectstatement2_ == old_child:
            self.set_selectstatement2(new_child)


class AExactlySelectstatement2(Node):
    def __init__(self, _exactly_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AExactlySelectstatement2, self).__init__()
        self._exactly_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _exactly_ is not None:
            self.set_exactly(_exactly_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _from_ is not None:
            self.set_from(_from_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _selectlist_ is not None:
            self.set_selectlist(_selectlist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AExactlySelectstatement2(self.clone_node(self._exactly_),
                                        self.clone_node(self._integer_),
                                        self.clone_node(self._from_),
                                        self.clone_node(self._l_par_),
                                        self.clone_node(self._selectlist_),
                                        self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_aexactlyselectstatement2(self)

    def get_exactly(self):
        return self._exactly_

    def set_exactly(self, node):
        if self._exactly_ is not None:
            self._exactly_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._exactly_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_from(self):
        return self._from_

    def set_from(self, node):
        if self._from_ is not None:
            self._from_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._from_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_selectlist(self):
        return self._selectlist_

    def set_selectlist(self, node):
        if self._selectlist_ is not None:
            self._selectlist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectlist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._exactly_) + self.to_string(self._integer_) \
               + self.to_string(self._from_) + self.to_string(self._l_par_) \
               + self.to_string(self._selectlist_) + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._exactly_ == child:
            self._exactly_ = None
        elif self._integer_ == child:
            self._integer_ = None
        elif self._from_ == child:
            self._from_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._selectlist_ == child:
            self._selectlist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._exactly_ == old_child:
            self.set_exactly(new_child)
        elif self._integer_ == old_child:
            self.set_integer(new_child)
        elif self._from_ == old_child:
            self.set_from(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._selectlist_ == old_child:
            self.set_selectlist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


class AAtleastSelectstatement2(Node):
    def __init__(self, _atleast_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AAtleastSelectstatement2, self).__init__()
        self._atleast_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _atleast_ is not None:
            self.set_atleast(_atleast_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _from_ is not None:
            self.set_from(_from_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _selectlist_ is not None:
            self.set_selectlist(_selectlist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AAtleastSelectstatement2(self.clone_node(self._atleast_),
                                        self.clone_node(self._integer_),
                                        self.clone_node(self._from_),
                                        self.clone_node(self._l_par_),
                                        self.clone_node(self._selectlist_),
                                        self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_aatleastselectstatement2(self)

    def get_atleast(self):
        return self._atleast_

    def set_atleast(self, node):
        if self._atleast_ is not None:
            self._atleast_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._atleast_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_from(self):
        return self._from_

    def set_from(self, node):
        if self._from_ is not None:
            self._from_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._from_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_selectlist(self):
        return self._selectlist_

    def set_selectlist(self, node):
        if self._selectlist_ is not None:
            self._selectlist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectlist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._atleast_) + self.to_string(self._integer_) \
               + self.to_string(self._from_) + self.to_string(self._l_par_) \
               + self.to_string(self._selectlist_) + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._atleast_ == child:
            self._atleast_ = None
        elif self._integer_ == child:
            self._integer_ = None
        elif self._from_ == child:
            self._from_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._selectlist_ == child:
            self._selectlist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._atleast_ == old_child:
            self.set_atleast(new_child)
        elif self._integer_ == old_child:
            self.set_integer(new_child)
        elif self._from_ == old_child:
            self.set_from(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._selectlist_ == old_child:
            self.set_selectlist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


class ANotmorethanSelectstatement2(Node):
    def __init__(self, _notmorethan_=None, _integer_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(ANotmorethanSelectstatement2, self).__init__()
        self._notmorethan_ = None
        self._integer_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _notmorethan_ is not None:
            self.set_notmorethan(_notmorethan_)
        if _integer_ is not None:
            self.set_integer(_integer_)
        if _from_ is not None:
            self.set_from(_from_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _selectlist_ is not None:
            self.set_selectlist(_selectlist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return ANotmorethanSelectstatement2(self.clone_node(self._notmorethan_),
                                            self.clone_node(self._integer_),
                                            self.clone_node(self._from_),
                                            self.clone_node(self._l_par_),
                                            self.clone_node(self._selectlist_),
                                            self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_anotmorethanselectstatement2(self)

    def get_notmorethan(self):
        return self._notmorethan_

    def set_notmorethan(self, node):
        if self._notmorethan_ is not None:
            self._notmorethan_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._notmorethan_ = node

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def get_from(self):
        return self._from_

    def set_from(self, node):
        if self._from_ is not None:
            self._from_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._from_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_selectlist(self):
        return self._selectlist_

    def set_selectlist(self, node):
        if self._selectlist_ is not None:
            self._selectlist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectlist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._notmorethan_) + self.to_string(self._integer_) \
               + self.to_string(self._from_) + self.to_string(self._l_par_) \
               + self.to_string(self._selectlist_) + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._notmorethan_ == child:
            self._notmorethan_ = None
        elif self._integer_ == child:
            self._integer_ = None
        elif self._from_ == child:
            self._from_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._selectlist_ == child:
            self._selectlist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._notmorethan_ == old_child:
            self.set_notmorethan(new_child)
        elif self._integer_ == old_child:
            self.set_integer(new_child)
        elif self._from_ == old_child:
            self.set_from(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._selectlist_ == old_child:
            self.set_selectlist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


# pylint: disable=too-many-instance-attributes,too-many-public-methods
class AAtleastnotmorethanSelectstatement2(Node):
    def __init__(self, _atleast_=None, _atleastnumber_=None, _logicsymbol_=None,
                 _notmorethan_=None, _notmorethannumber_=None, _from_=None, _l_par_=None,
                 _selectlist_=None, _r_par_=None):
        super(AAtleastnotmorethanSelectstatement2, self).__init__()
        self._atleast_ = None
        self._atleastnumber_ = None
        self._logicsymbol_ = None
        self._notmorethan_ = None
        self._notmorethannumber_ = None
        self._from_ = None
        self._l_par_ = None
        self._selectlist_ = None
        self._r_par_ = None
        if _atleast_ is not None:
            self.set_atleast(_atleast_)
        if _atleastnumber_ is not None:
            self.set_atleastnumber(_atleastnumber_)
        if _logicsymbol_ is not None:
            self.set_logicsymbol(_logicsymbol_)
        if _notmorethan_ is not None:
            self.set_notmorethan(_notmorethan_)
        if _notmorethannumber_ is not None:
            self.set_notmorethannumber(_notmorethannumber_)
        if _from_ is not None:
            self.set_from(_from_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _selectlist_ is not None:
            self.set_selectlist(_selectlist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AAtleastnotmorethanSelectstatement2(self.clone_node(self._atleast_),
                                                   self.clone_node(self._atleastnumber_),
                                                   self.clone_node(self._logicsymbol_),
                                                   self.clone_node(self._notmorethan_),
                                                   self.clone_node(self._notmorethannumber_),
                                                   self.clone_node(self._from_),
                                                   self.clone_node(self._l_par_),
                                                   self.clone_node(self._selectlist_),
                                                   self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_aatleastnotmorethanselectstatement2(self)

    def get_atleast(self):
        return self._atleast_

    def set_atleast(self, node):
        if self._atleast_ is not None:
            self._atleast_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._atleast_ = node

    def get_atleastnumber(self):
        return self._atleastnumber_

    def set_atleastnumber(self, node):
        if self._atleastnumber_ is not None:
            self._atleastnumber_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._atleastnumber_ = node

    def get_logicsymbol(self):
        return self._logicsymbol_

    def set_logicsymbol(self, node):
        if self._logicsymbol_ is not None:
            self._logicsymbol_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._logicsymbol_ = node

    def get_notmorethan(self):
        return self._notmorethan_

    def set_notmorethan(self, node):
        if self._notmorethan_ is not None:
            self._notmorethan_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._notmorethan_ = node

    def get_notmorethannumber(self):
        return self._notmorethannumber_

    def set_notmorethannumber(self, node):
        if self._notmorethannumber_ is not None:
            self._notmorethannumber_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._notmorethannumber_ = node

    def get_from(self):
        return self._from_

    def set_from(self, node):
        if self._from_ is not None:
            self._from_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._from_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_selectlist(self):
        return self._selectlist_

    def set_selectlist(self, node):
        if self._selectlist_ is not None:
            self._selectlist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._selectlist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._atleast_) + self.to_string(self._atleastnumber_) \
               + self.to_string(self._logicsymbol_) + self.to_string(self._notmorethan_) \
               + self.to_string(self._notmorethannumber_) + self.to_string(self._from_) \
               + self.to_string(self._l_par_) + self.to_string(self._selectlist_) \
               + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._atleast_ == child:
            self._atleast_ = None
        elif self._atleastnumber_ == child:
            self._atleastnumber_ = None
        elif self._logicsymbol_ == child:
            self._logicsymbol_ = None
        elif self._notmorethan_ == child:
            self._notmorethan_ = None
        elif self._notmorethannumber_ == child:
            self._notmorethannumber_ = None
        elif self._from_ == child:
            self._from_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._selectlist_ == child:
            self._selectlist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._atleast_ == old_child:
            self.set_atleast(new_child)
        elif self._atleastnumber_ == old_child:
            self.set_atleastnumber(new_child)
        elif self._logicsymbol_ == old_child:
            self.set_logicsymbol(new_child)
        elif self._notmorethan_ == old_child:
            self.set_notmorethan(new_child)
        elif self._notmorethannumber_ == old_child:
            self.set_notmorethannumber(new_child)
        elif self._from_ == old_child:
            self.set_from(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._selectlist_ == old_child:
            self.set_selectlist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


class ASelectlist(Node):
    def __init__(self, _residue_=None, _listitems_=None):
        super(ASelectlist, self).__init__()
        self._residue_ = None
        self._listitems_ = list()
        if _residue_ is not None:
            self.set_residue(_residue_)
        if _listitems_ is not None:
            self._listitems_.extend(_listitems_)

    def clone(self):
        return ASelectlist(self.clone_node(self._residue_), self.clone_list(self._listitems_))

    def apply(self, analysis):
        analysis.case_aselectlist(self)

    def get_residue(self):
        return self._residue_

    def set_residue(self, node):
        if self._residue_ is not None:
            self._residue_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._residue_ = node

    def get_listitems(self):
        return self._listitems_

    def set_listitems(self, lst):
        del self._listitems_[0:len(self._listitems_)]
        self._listitems_.extend(lst)

    def __str__(self):
        return '' + self.to_string(self._residue_) + self.to_string(self._listitems_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._residue_ == child:
            self._residue_ = None
            return
        if child in self._listitems_:
            self._listitems_.remove(child)
            return

    def replace_child(self, old_child, new_child):
        if self._residue_ == old_child:
            self.set_residue(new_child)
            return
        for i in range(self._listitems_):
            if self._listitems_[i] == old_child:
                if new_child is not None:
                    self._listitems_[i] = new_child
                    old_child.set_parent(None)
                    return

                del self._listitems_[i]
                old_child.set_parent(None)
                return


class AListitems(Node):
    def __init__(self, _comma_=None, _residue_=None):
        super(AListitems, self).__init__()
        self._comma_ = None
        self._residue_ = None
        if _comma_ is not None:
            self.set_comma(_comma_)
        if _residue_ is not None:
            self.set_residue(_residue_)

    def clone(self):
        return AListitems(self.clone_node(self._comma_), self.clone_node(self._residue_))

    def apply(self, analysis):
        analysis.case_alistitems(self)

    def get_comma(self):
        return self._comma_

    def set_comma(self, node):
        if self._comma_ is not None:
            self._comma_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._comma_ = node

    def get_residue(self):
        return self._residue_

    def set_residue(self, node):
        if self._residue_ is not None:
            self._residue_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._residue_ = node

    def __str__(self):
        return '' + self.to_string(self._comma_) + self.to_string(self._residue_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._comma_ == child:
            self._comma_ = None
        elif self._residue_ == child:
            self._residue_ = None

    def replace_child(self, old_child, new_child):
        if self._comma_ == old_child:
            self.set_comma(new_child)
        elif self._residue_ == old_child:
            self.set_residue(new_child)


class AScorecondition(Node):
    def __init__(self, _score_=None, _from_=None, _l_par_=None, _scorelist_=None, _r_par_=None):
        super(AScorecondition, self).__init__()
        self._score_ = None
        self._from_ = None
        self._l_par_ = None
        self._scorelist_ = None
        self._r_par_ = None
        if _score_ is not None:
            self.set_score(_score_)
        if _from_ is not None:
            self.set_from(_from_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _scorelist_ is not None:
            self.set_scorelist(_scorelist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AScorecondition(self.clone_node(self._score_), self.clone_node(self._from_),
                               self.clone_node(self._l_par_), self.clone_node(self._scorelist_),
                               self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_ascorecondition(self)

    def get_score(self):
        return self._score_

    def set_score(self, node):
        if self._score_ is not None:
            self._score_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._score_ = node

    def get_from(self):
        return self._from_

    def set_from(self, node):
        if self._from_ is not None:
            self._from_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._from_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_scorelist(self):
        return self._scorelist_

    def set_scorelist(self, node):
        if self._scorelist_ is not None:
            self._scorelist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._scorelist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._score_) + self.to_string(self._from_) \
               + self.to_string(self._l_par_) + self.to_string(self._scorelist_) \
               + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._score_ == child:
            self._score_ = None
        elif self._from_ == child:
            self._from_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._scorelist_ == child:
            self._scorelist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._score_ == old_child:
            self.set_score(new_child)
        elif self._from_ == old_child:
            self.set_from(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._scorelist_ == old_child:
            self.set_scorelist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


class AScorelist(Node):
    def __init__(self, _scoreitem_=None, _scoreitems_=None):
        super(AScorelist, self).__init__()
        self._scoreitem_ = None
        self._scoreitems_ = list()
        if _scoreitem_ is not None:
            self.set_scoreitem(_scoreitem_)
        if _scoreitems_ is not None:
            self._scoreitems_.extend(_scoreitems_)

    def clone(self):
        return AScorelist(self.clone_node(self._scoreitem_), self.clone_list(self._scoreitems_))

    def apply(self, analysis):
        analysis.case_ascorelist(self)

    def get_scoreitem(self):
        return self._scoreitem_

    def set_scoreitem(self, node):
        if self._scoreitem_ is not None:
            self._scoreitem_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._scoreitem_ = node

    def get_scoreitems(self):
        return self._scoreitems_

    def set_scoreitems(self, lst):
        del self._scoreitems_[0:len(self._scoreitems_)]
        self._scoreitems_.extend(lst)

    def __str__(self):
        return '' + self.to_string(self._scoreitem_) + self.to_string(self._scoreitems_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._scoreitem_ == child:
            self._scoreitem_ = None
        elif child in self._scoreitems_:
            self._scoreitems_.remove(child)

    def replace_child(self, old_child, new_child):
        if self._scoreitem_ == old_child:
            self.set_scoreitem(new_child)
            return
        for i in range(self._scoreitems_):
            if self._scoreitems_[i] == old_child:
                if new_child is not None:
                    self._scoreitems_[i] = new_child
                    old_child.set_parent(None)
                    return

                del self._scoreitems_[i]
                old_child.set_parent(None)
                return


class AStatementScoreitem(Node):
    def __init__(self, _booleancondition_=None, _mapper_=None, _min_=None, _number_=None):
        super(AStatementScoreitem, self).__init__()
        self._booleancondition_ = None
        self._mapper_ = None
        self._min_ = None
        self._number_ = None
        if _booleancondition_ is not None:
            self.set_booleancondition(_booleancondition_)
        if _mapper_ is not None:
            self.set_mapper(_mapper_)
        if _min_ is not None:
            self.set_min(_min_)
        if _number_ is not None:
            self.set_number(_number_)

    def clone(self):
        return AStatementScoreitem(self.clone_node(self._booleancondition_),
                                   self.clone_node(self._mapper_), self.clone_node(self._min_),
                                   self.clone_node(self._number_))

    def apply(self, analysis):
        analysis.case_astatementscoreitem(self)

    def get_booleancondition(self):
        return self._booleancondition_

    def set_booleancondition(self, node):
        if self._booleancondition_ is not None:
            self._booleancondition_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._booleancondition_ = node

    def get_mapper(self):
        return self._mapper_

    def set_mapper(self, node):
        if self._mapper_ is not None:
            self._mapper_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._mapper_ = node

    def get_min(self):
        return self._min_

    def set_min(self, node):
        if self._min_ is not None:
            self._min_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._min_ = node

    def get_number(self):
        return self._number_

    def set_number(self, node):
        if self._number_ is not None:
            self._number_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._number_ = node

    def __str__(self):
        return '' + self.to_string(self._booleancondition_) + self.to_string(self._mapper_) \
               + self.to_string(self._min_) + self.to_string(self._number_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._booleancondition_ == child:
            self._booleancondition_ = None
        elif self._mapper_ == child:
            self._mapper_ = None
        elif self._min_ == child:
            self._min_ = None
        elif self._number_ == child:
            self._number_ = None

    def replace_child(self, old_child, new_child):
        if self._booleancondition_ == old_child:
            self.set_booleancondition(new_child)
        elif self._mapper_ == old_child:
            self.set_mapper(new_child)
        elif self._min_ == old_child:
            self.set_min(new_child)
        elif self._number_ == old_child:
            self.set_number(new_child)


class AMaxScoreitem(Node):
    def __init__(self, _max_=None, _l_par_=None, _scorelist_=None, _r_par_=None):
        super(AMaxScoreitem, self).__init__()
        self._max_ = None
        self._l_par_ = None
        self._scorelist_ = None
        self._r_par_ = None
        if _max_ is not None:
            self.set_max(_max_)
        if _l_par_ is not None:
            self.set_lpar(_l_par_)
        if _scorelist_ is not None:
            self.set_scorelist(_scorelist_)
        if _r_par_ is not None:
            self.set_rpar(_r_par_)

    def clone(self):
        return AMaxScoreitem(self.clone_node(self._max_), self.clone_node(self._l_par_),
                             self.clone_node(self._scorelist_), self.clone_node(self._r_par_))

    def apply(self, analysis):
        analysis.case_amaxscoreitem(self)

    def get_max(self):
        return self._max_

    def set_max(self, node):
        if self._max_ is not None:
            self._max_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._max_ = node

    def get_lpar(self):
        return self._l_par_

    def set_lpar(self, node):
        if self._l_par_ is not None:
            self._l_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._l_par_ = node

    def get_scorelist(self):
        return self._scorelist_

    def set_scorelist(self, node):
        if self._scorelist_ is not None:
            self._scorelist_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._scorelist_ = node

    def get_rpar(self):
        return self._r_par_

    def set_rpar(self, node):
        if self._r_par_ is not None:
            self._r_par_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._r_par_ = node

    def __str__(self):
        return '' + self.to_string(self._max_) + self.to_string(self._l_par_) \
               + self.to_string(self._scorelist_) + self.to_string(self._r_par_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._max_ == child:
            self._max_ = None
        elif self._l_par_ == child:
            self._l_par_ = None
        elif self._scorelist_ == child:
            self._scorelist_ = None
        elif self._r_par_ == child:
            self._r_par_ = None

    def replace_child(self, old_child, new_child):
        if self._max_ == old_child:
            self.set_max(new_child)
        elif self._l_par_ == old_child:
            self.set_lpar(new_child)
        elif self._scorelist_ == old_child:
            self.set_scorelist(new_child)
        elif self._r_par_ == old_child:
            self.set_rpar(new_child)


class AScoreitems(Node):
    def __init__(self, _comma_=None, _scoreitem_=None):
        super(AScoreitems, self).__init__()
        self._comma_ = None
        self._scoreitem_ = None
        if _comma_ is not None:
            self.set_comma(_comma_)
        if _scoreitem_ is not None:
            self.set_scoreitem(_scoreitem_)

    def clone(self):
        return AScoreitems(self.clone_node(self._comma_), self.clone_node(self._scoreitem_))

    def apply(self, analysis):
        analysis.case_ascoreitems(self)

    def get_comma(self):
        return self._comma_

    def set_comma(self, node):
        if self._comma_ is not None:
            self._comma_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._comma_ = node

    def get_scoreitem(self):
        return self._scoreitem_

    def set_scoreitem(self, node):
        if self._scoreitem_ is not None:
            self._scoreitem_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._scoreitem_ = node

    def __str__(self):
        return '' + self.to_string(self._comma_) + self.to_string(self._scoreitem_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._comma_ == child:
            self._comma_ = None
        elif self._scoreitem_ == child:
            self._scoreitem_ = None

    def replace_child(self, old_child, new_child):
        if self._comma_ == old_child:
            self.set_comma(new_child)
        elif self._scoreitem_ == old_child:
            self.set_scoreitem(new_child)


class AIntegerNumber(Node):
    def __init__(self, _integer_=None):
        super(AIntegerNumber, self).__init__()
        self._integer_ = None
        if _integer_ is not None:
            self.set_integer(_integer_)

    def clone(self):
        return AIntegerNumber(self.clone_node(self._integer_))

    def apply(self, analysis):
        analysis.case_aintegernumber(self)

    def get_integer(self):
        return self._integer_

    def set_integer(self, node):
        if self._integer_ is not None:
            self._integer_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._integer_ = node

    def __str__(self):
        return '' + self.to_string(self._integer_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._integer_ == child:
            self._integer_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._integer_ == old_child:
            self.set_integer(new_child)
            return


class AFloatNumber(Node):
    def __init__(self, _float_=None):
        super(AFloatNumber, self).__init__()
        self._float_ = None
        if _float_ is not None:
            self.set_float(_float_)

    def clone(self):
        return AFloatNumber(self.clone_node(self._float_))

    def apply(self, analysis):
        analysis.case_afloatnumber(self)

    def get_float(self):
        return self._float_

    def set_float(self, node):
        if self._float_ is not None:
            self._float_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._float_ = node

    def __str__(self):
        return '' + self.to_string(self._float_)

    def __repr__(self):
        return "'" + self.__str__() + "'"

    def remove_child(self, child):
        if self._float_ == child:
            self._float_ = None
            return

    def replace_child(self, old_child, new_child):
        if self._float_ == old_child:
            self.set_float(new_child)
            return


class Start(Node):
    def __init__(self, _base_=None, _eof_=None):
        super(Start, self).__init__()
        self._base_ = None
        self._eof_ = None
        self.set_pstatement(_base_)
        self.set_eof(_eof_)

    def clone(self):
        return Start(self.clone_node(self._base_), self.clone_node(self._eof_))

    def apply(self, analysis):
        analysis.case_start(self)

    def get_pstatement(self):
        return self._base_

    def set_pstatement(self, node):
        if self._base_ is not None:
            self._base_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._base_ = node

    def get_eof(self):
        return self._eof_

    def set_eof(self, node):
        if self._eof_ is not None:
            self._eof_.set_parent(None)

        if node is not None:
            if node.get_parent() is not None:
                node.get_parent().remove_child(node)

            node.set_parent(self)

        self._eof_ = node

    def remove_child(self, child):
        if self._base_ == child:
            self._base_ = None
        elif self._eof_ == child:
            self._eof_ = None

    def replace_child(self, old_child, new_child):
        if self._base_ == old_child:
            self.set_pstatement(new_child)
        elif self._eof_ == old_child:
            self.set_eof(new_child)

    def __str__(self):
        return '' + self.to_string(self._base_) + self.to_string(self._eof_)

    def __repr__(self):
        return "'" + self.__str__() + "'"
